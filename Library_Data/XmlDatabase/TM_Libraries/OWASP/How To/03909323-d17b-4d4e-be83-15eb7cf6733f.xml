<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="1230187256" Content_Hash="-752372723">
  <Metadata>
    <Id>03909323-d17b-4d4e-be83-15eb7cf6733f</Id>
    <Library_Id>00000000-0000-0000-0000-000000000000</Library_Id>
    <Title>How to Test for Known Plaintext Bugs</Title>
    <Category>Cryptography</Category>
    <Phase>Test</Phase>
    <Technology> Any</Technology>
    <Type>How To</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies to:</h1><ul><li>Public and private key encryption systems.<strong></strong></li></ul><p><strong>&nbsp;</strong></p><h1>Summary</h1><p>In known plaintext attacks the adversary knows both the plaintext and its equivalent ciphertext, and then uses both to calculate a secret cryptographic variable such as the encryption key.&nbsp;&nbsp; Known plaintext bugs are simple to exploit as the attacker doesn’t need to force the victim into encrypting any particular chosen plaintext.</p><p>The following steps are recommended to test for known plaintext bugs:</p><ul><li>Step 1:&nbsp; Understand Attack Scenarios</li><li>Step 2:&nbsp; Analyze Root Causes and Mitigations</li><li>Step 3:&nbsp; Start Testing and Exploring</li><li>Step 4:&nbsp; Tune Test Cases</li></ul><p><strong>&nbsp;</strong></p><h1>Step 1:&nbsp; Understand Attack Scenario </h1><p>First, you need to understand the details of known plaintext attacks.&nbsp; In the common known plaintext attack scenario the adversary’s goal is to recover the encryption key.&nbsp; The scenario starts with the attacker selecting the victim and discovering the plaintext that the victim encrypts.&nbsp; The attacker then waits until the victim encrypts the plaintext and observes the resulting ciphertext.&nbsp; Then, the attacker uses both the plaintext and ciphertext to recover the encryption key that satisfies the next equation:</p><p><em>C = E(K, P)</em></p><p>Where <em>E </em>stands for the encryption routine that converts plaintext <em>P</em> in to ciphertext <em>C</em> using the encryption key<em> K.</em></p><p>If the adversary is able to compute the encryption key, he can use it to decrypt an unknown ciphertext, as the following equation demonstrates:</p><p><em>Pu</em><em>&nbsp;= D(K, Ck)</em></p><p>Where <em>D </em>stands for the decryption routine that converts a known ciphertext <em>Ck </em>to the unknown plaintext <em>Pu</em> to using the encryption key<em> K.</em></p><p>The adversary is able to decrypt any ciphertext created using the stolen key, including potentially sensitive data such as passwords and credit card numbers.<em></em></p><p><strong>&nbsp;</strong></p><h2>Step 2:&nbsp; Analyze Root Cause and Mitigations</h2><p>As the section’s name indicates, the success of plaintext attacks depends on <em>knowing</em> the plaintext that is encrypted.&nbsp; It may seem improbable that an adversary gains knowledge of any plaintext; yet nonetheless there are some circumstances where this can happen.&nbsp; For instance, if the victim is out of the office and has an auto-reply email message configured; the attacker may very well know what the message looks like before it’s encrypted.&nbsp; Another common example is where the victim sends an email to a group of people including the attacker.&nbsp; The attacker can then read the plaintext sent to him, and the ciphertext sent to everybody else.&nbsp; &nbsp;</p><p>An additional attack might consist of the attacker sniffing an email conversation between two people exchanging an encrypted document as part of a review process.&nbsp; When the document is published the attacker can compare the plaintext publication with the latest version of the encrypted file.&nbsp; &nbsp;<em>Partially known</em> plaintext attacks occur when the adversary knows part of the plaintext such as headers of IP packets, the beginning of emails, etc.&nbsp; There are different ways for an adversary to know the plaintext in use - a root cause for this vulnerability is any situation which allows the adversary to be aware of such plaintext.</p><p>There are no clear mitigations against these attacks as most of the causes happen by design.&nbsp; For instance, email servers provide the functionality to have auto-reply messages.&nbsp; Furthermore, in the case where the victim sends the attacker a copy of a group email, there is no way to prevent the victim from emailing the attacker if the attacker is part of the group.&nbsp; Consider the case where the attacker sniffs an encrypted document in review: possible mitigations for this attack require higher level analysis and education, such as requiring the people involved in the document review to check the document in to an Intranet portal or similar mechanism rather than transferring it back and forth via email.&nbsp; </p><p>&nbsp;</p><h1>Step 3:&nbsp; Start Testing and Exploring </h1><p>Now that you’ve learned what known plaintext attacks look like and the reasons why they exist, you must test for both secure and insecure implementations.</p><p>The basic known plaintext security testing follows these steps:</p><ol><li>Select the victim.</li><li>Read plaintext before the victim encrypts it.</li><li>Read the ciphertext after the victim encrypts it.</li><li>Use the plaintext and ciphertext to calculate the encryption key.</li></ol><p><em>Expected result:</em>&nbsp; The system protects against reading the plaintext before it is encrypted in step 2.&nbsp; The test fails if you can execute step 2.</p><p>It is important that during this step you explore the encryption routine used by the system under test.&nbsp; For example, you can check the size of the data before and after encryption.&nbsp; If the encryption routine doesn’t modify the data size then the plaintext and ciphertext have the same size.&nbsp; You can later compare the sizes as a preliminary check to see if the ciphertext matches the known plaintext. </p><p>Another way to test for known plaintext bugs is to become a valid user of the encryption system.&nbsp; For instance, picture a system that has multiple clients and uses a different key to talk to each client.&nbsp; After becoming a valid client, you can configure a network monitor to see how the server application communicates with you.&nbsp; In most cases, server applications use the same protocol to talk to multiple clients, so parts of the network packets (such as headers) will be constant.&nbsp; You can read these headers in plaintext as they arrive to you or as ciphertext as they arrive to each client, and use this pair of collected data to execute an attack on a client’s private key.&nbsp;&nbsp;&nbsp;&nbsp; </p><p>&nbsp;</p><h1>Step 4:&nbsp; Tune Test Cases</h1><p>Like any vulnerability, the amount of testing for known plaintext attacks depends on their risk.&nbsp; In some cases they represent no obvious risk; the time to compute the key using any known cryptanalysis in systems using large keys and a trusted encryption algorithm may be too great to represent a high risk.&nbsp; However, some systems are mission critical, hermetic, or self contained, and in such cases any possible knowledge of the plaintext before it is encrypted can pose a high risk.&nbsp;&nbsp; </p><p>You must also decide what your attack goals are before testing.&nbsp; Make sure to define the attack’s goal in each test case (such as breaking a client’s key, the server’s key, or both.)&nbsp; Some keys are more critical to the security of the system under test than others, and you can use this fact to tune your test cases.</p><p><strong>&nbsp;</strong></p><h1>Conclusions</h1><p>Known plaintext attacks are cryptographic attacks in which the adversary knows the plaintext before it is encrypted.&nbsp; The goal of the attack is to calculate the encryption key to gather additional sensitive data.&nbsp; To test for these attacks, you need to understand their attack scenarios as well as their root causes and mitigations.&nbsp; Then, start testing from the ground up, such as checking message data lengths, and then additional approaches should be used such as becoming a legitimate client of the system and analyzing the format of the encrypted text that is being transmitted.&nbsp; Make sure to tune your test cases based on the sensitivity of the particular encryption key, and the risk potential of an attacker stealing it.<strong><span style="text-decoration:underline"></span></strong></p><p><strong>&nbsp;</strong></p><p><strong>&nbsp;</strong></p><p><strong>&nbsp;</strong></p><p>&nbsp;</p>]]></Data>
  </Content>
</TeamMentor_Article>