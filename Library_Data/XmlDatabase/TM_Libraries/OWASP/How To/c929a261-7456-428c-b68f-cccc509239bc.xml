<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-648965192" Content_Hash="611798573">
  <Metadata>
    <Id>c929a261-7456-428c-b68f-cccc509239bc</Id>
    <Library_Id>00000000-0000-0000-0000-000000000000</Library_Id>
    <Title>How to Test for XML Injection Bugs</Title>
    <Category>Input and Data Validation</Category>
    <Phase>Test</Phase>
    <Technology> Any</Technology>
    <Type>How To</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority />
    <Status />
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies To:</h1><ul><li>Web services that use XML communication protocols written in web languages such as ASP, PHP, Java, and similar languages. </li><li>Web services that use SOAP communication.</li></ul><p><strong></strong>&nbsp;</p><h1>Summary</h1><p>XML stands for Extensible Markup Language.&nbsp; Similar to HTML, it utilizes tags to store structured data.&nbsp; However, XML is extensible as it allows users to define their own elements in user defined tags.</p><p>In web software, the two most noticeable uses for XML are: </p><ol><li>Store structured data as an alternative to a database. </li><li>Provide a transaction protocol for business-to-business and business-to-client communications (such as SOAP.)</li></ol><h3><em>Store structured data as an alternative to a database</em></h3><p>A server stores user names, passwords, and emails in the <strong><em>user</em></strong> element.&nbsp; It uses a web form to collect user data:</p><p><img src="X:\Trash\GE\clip_image001.png"><strong>&nbsp;</strong></p><p>A user enters the following data and clicks on the <em>Create User</em> button:</p><pre><strong>Username: JohnyC</strong></pre><pre><strong></strong><strong>Password: qwerty</strong></pre><pre><strong>E-mail: johnyc@examplesite.com</strong></pre><p>The client sends this URL to the server application:&nbsp;</p><pre><strong>http://www.examplesite.com/GetProfile.php?username=JohnyC&amp;password=qwerty &amp;email=JohnyC@examplesite.com</strong></pre><pre><strong></strong></pre><p>Once the server receives the URL it creates a <strong><em>user</em></strong> <em>XML</em> <em>element</em> <em>node:</em><strong>&nbsp;</strong></p><pre>&lt;user&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;username&gt;JohnyC&lt;/username&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password&gt;qwerty&lt;/password&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;userid&gt;111&lt;userid/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;mail&gt;JohnyC@examplesite.com&lt;/mail&gt;</pre><pre>&lt;/user&gt;</pre><pre><strong><em></em></strong>&nbsp;</pre><h3><em>Provide a transaction protocol for business-to-business and business-to-client communications (such as SOAP)</em></h3><p>The second and most used XML benefit is to integrate web services.&nbsp; SOAP is the communication protocol for XML web services.&nbsp; Before XML, systems had to implement Remote Procedure Calls (RPC) to integrate cross platform services on the web.&nbsp; At that time COBRA or DCE were mostly used to achieve integration, but they were too complex.&nbsp;&nbsp; SOAP defined a standard XML communication protocol that was adopted because of its simplicity.&nbsp; As Microsoft released SOAP, they also released a toolkit that translated COM to SOAP, as well as one to translate Java Functions to SOAP.&nbsp;&nbsp; </p><p>The following code shows an XML-based SOAP client that invokes the <strong>sayHello </strong>method on a SOAP server<a href="about:blank#_edn1" name="_ednref1">[i]</a>:</p><pre>Dim x, h</pre><pre>Set x = CreateObject("MSXML2.DOMDocument")</pre><pre>x.loadXML "&lt;s:Envelope xmlns:s='http://schemas.xmlsoap.org/soap/envelope/' </pre><pre>&nbsp; xmlns:xsi='http://www.w3.org/1999/XMLSchema-instance' </pre><pre>&nbsp; xmlns:xsd='http://www.w3.org/1999/XMLSchema'&gt;&lt;s:Body&gt;&lt;m:sayHello </pre><pre>&nbsp; xmlns:m='urn:Example1'&gt;&lt;name xsi:type='xsd:string'&gt;James&lt;/name&gt;&lt;</pre><pre>&nbsp; /m:sayHello&gt;&lt;/s:Body&gt;&lt;/s:Envelope&gt;"</pre><pre>msgbox x.xml, , "Input SOAP Message"</pre><pre>Set h = CreateObject("Microsoft.XMLHTTP")</pre><pre>h.open "POST", "http://localhost:8080"</pre><pre>h.send (x)</pre><pre>while h.readyState &lt;&gt; 4</pre><pre>wend</pre><pre>msgbox h.responseText,,"Output SOAP Message"</pre><pre>&nbsp;</pre><p>For more information about XML Web Services, refer to theMSDN article on the topic<a href="about:blank#_edn2" name="_ednref2">[ii]</a></p><p><strong><em>&nbsp;</em></strong></p><h3><em>XML Injection Bugs</em></h3><p>XML injection means to maliciously feed crafted data to a XML-based web service in order to execute an attack.&nbsp; An XML injection attack varies from adding extra elements in an XML store to tamper with sensitive information to modifying XML store tags to execute cross-site scripting code in a target browser.</p><p>The following steps are needed to test for XML Injection:</p><ol><li>Understand XML Injection attack scenarios. </li><li>Identify high risk components. </li><li>Start testing and exploring. </li><li>Tune test cases.</li></ol><p><strong>Important: </strong>&nbsp;&nbsp;It is necessary to differentiate XML injection with <strong><em>XPATH</em></strong> or <strong><em>XQUERY </em></strong>bugs.&nbsp; They are similar as they both relate to XML, but the logic involved is fundamentally different and will be discussed in individual articles.</p><p><strong>&nbsp;</strong></p><h1>Step 1:&nbsp; Understand XML Injection attack scenarios</h1><p>During the first step, you need to understand how an XML injection attack works both in storage and communication.&nbsp; The following two scenarios elaborate on XML injection attacks:</p><ul><li>Injecting an extra tag to a XML data store. </li><li>Executing cross-site scripting attacks by manipulating the CDATA tag.</li></ul><p>&nbsp;</p><h2><em>Scenario 1:&nbsp; Injecting an extra tag to a XML data store</em></h2><p>A bank site exposes a simple web page to create checking accounts. &nbsp;It takes data from a web form like the one above and builds a URL like this one:</p><pre><strong>http://www.examplesite.com/CreateChecking.php?username=JohnyC&amp;password=qwerty&amp;email=JohnyC@examplesite.com</strong></pre><p>&nbsp;The bank uses the data in the URL to construct the following XML in its data store:</p><pre>&lt;user&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;username&gt;JohnyC&lt;/username&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password&gt;qwerty&lt;/password&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;userid&gt;111&lt;userid/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;mail&gt;JohnyC@examplesite.com&lt;/mail&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;account type=”checking”&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;created&gt;02-21-2008&lt;/created&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;number&gt;1249109&lt;/number&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;balance&gt;1201&lt;/balance&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/account&gt; </pre><pre>&nbsp;</pre><pre>&lt;/user&gt;</pre><p>The bank doesn’t provide a web interface to create saving accounts.&nbsp; In order to open a saving account, clients need to go to the bank and provide additional information.&nbsp; The bank exposes a security vulnerability that allows the attacker to feed malicious data in the web form.&nbsp; The attacker submits the following URL request:</p><pre><strong>http://www.examplesite.com/CreateChecking.php?username=JohnyC&amp;password=qwerty&amp;email=JohnyC@examplesite.com&lt;/mail&gt;&lt;account type="savings"&gt;&lt;created&gt;03-02-2008&lt;/created&gt;&lt;number&gt;12345678&lt;/number&gt;&lt;balance&gt;1000000&lt;/balance&gt;&lt;/account&gt;</strong></pre><p>&nbsp;When the bank receives this request it doesn’t check for extra tags and builds the following element in its data store:</p><pre>&lt;user&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;username&gt;JohnyC&lt;/username&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password&gt;qwerty&lt;/password&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;userid&gt;111&lt;userid/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;mail&gt;JohnyC@examplesite.com&lt;/mail&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;account type="savings"&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;created&gt;03-02-2008&lt;/created&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;number&gt;12345678&lt;/number&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;balance&gt;1000000&lt;/balance&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/account&gt;</pre><pre>&nbsp;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;account type=”checking”&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;created&gt;02-21-2008&lt;/created&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;number&gt;1249109&lt;/number&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;balance&gt;1201&lt;/balance&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/account&gt; </pre><pre>&lt;/user&gt;</pre><p>&nbsp;</p><p>The bug in the bank web application here allows the attacker to remotely create a savings account with a $1000000 balance.</p><p><strong><em>&nbsp;</em></strong></p><h2><em>Scenario 2:&nbsp; Executing cross-site scripting attacks by manipulating the CDATA tag </em></h2><p>XML uses the CDATA tag to escape blocks of text that would be otherwise recognized as markup.&nbsp; All data enclosed in between the tags <strong>"&lt;![CDATA[" </strong>and <strong>"]]&gt;" </strong>will not be parsed as markup.&nbsp; </p><p>A vulnerable server uses a file named scenarios.xml to store the title and the data for each scenario:</p><pre>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</pre><pre>&lt;scenarios&gt;</pre><pre>&nbsp;</pre><pre>&lt;scenario&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;title&gt;XSS scenario&lt;/title&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;data&gt;&lt;![CDATA[this is not to be parsed &lt;!-- as XML '"&gt;&lt;]]&gt;&lt;/data&gt;</pre><pre>&lt;/scenario&gt;&nbsp;&nbsp;&nbsp; </pre><pre>&nbsp;</pre><pre>etc…</pre><pre>&nbsp;</pre><pre>&lt;/scenarios&gt;</pre><p><strong>&nbsp;</strong></p><p>The application blindly builds a page (scenarios.php) from the XML file using the following code and then sends the page back to the client:</p><p><strong>&nbsp;</strong></p><pre>&lt;? php</pre><pre>&nbsp;</pre><pre>&nbsp; $objDOM = new DOMDocument(); </pre><pre>&nbsp; $objDOM-&gt;load("scenarios.xml"); </pre><pre>&nbsp; $scenario = $objDOM-&gt;getElementsByTagName("scenario");</pre><pre>&nbsp; </pre><pre>&nbsp; foreach( $scenario as $value )</pre><pre>&nbsp; {</pre><pre>&nbsp;&nbsp;&nbsp; $title&nbsp; = $value-&gt;getElementsByTagName("title")-&gt;item(0)-&gt;nodeValue;</pre><pre>&nbsp;&nbsp;&nbsp; $data =&nbsp;&nbsp; $value-&gt;getElementsByTagName("data")-&gt;item(0)-&gt;nodeValue;</pre><pre>&nbsp;</pre><pre>&nbsp;&nbsp;&nbsp; echo "$title:&lt;br&gt;$data&lt;br&gt;";</pre><pre>&nbsp; }</pre><pre>&nbsp; </pre><pre>?&gt;</pre><p><strong>&nbsp;</strong></p><p>The scenario above will generate the following output:</p><pre>XSS scenario:<br>this is not be parsed as XML '"&gt;&lt;</pre><p><strong>&nbsp; </strong></p><p>Now the attacker gets control of scenarios.xml and modifies the data tag to look like this:<strong></strong></p><pre>&lt;scenario&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;title&gt;XSS scenario&lt;/title&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;data&gt;&lt;![CDATA[&lt;script&gt;alert('XSS')&lt;/script&gt;]]&gt;&lt;/data&gt;</pre><pre>&lt;/scenario&gt;&nbsp;&nbsp;&nbsp; </pre><p>&nbsp;</p><p>This will result in the vulnerable application building a page similar to the one below and sending it to the client:</p><pre>&lt;html&gt;</pre><pre>&nbsp;</pre><pre>XSS scenario:</pre><pre>&lt;script&gt;alert('XSS')&lt;/script&gt;</pre><pre>&nbsp;</pre><pre>&lt;/html&gt;</pre><p>&nbsp;</p><p>That finally results in a cross-site scripting attack because the server doesn’t validate the XML output before sending it back as HTML to the client.</p><p>&nbsp;</p><h1>Step 2:&nbsp; Identify high risk components</h1><p>The next steps for XML Injection testing are to list all of the places where code builds XML statements from user supplied input; and to understand how and where our application manipulates statements, and how it uses them to modify its data store or to invoke XML web methods.&nbsp; The most common are:</p><ul><li>Profile-related web pages. </li><li>E-Commerce or financial account-related pages. </li><li>XML web service interaction methods. </li><li>XML-based system-level clients. </li><li>Systems that read from XML backend and blindly construct responses to Internet clients.</li></ul><p>&nbsp;</p><h2><em>Identify all high risk components </em></h2><p>This subtask consists of indentifying the coding errors that lead to XML injection bugs.&nbsp; XML injection bugs exist for two main reasons.&nbsp; First, when a server-side application directly utilizes user-supplied strings that arrive over the Internet to add into their XML data store or perform other XML-related tasks.&nbsp; The application doesn’t do any sort of data validation on the strings, and therefore allows for injection of XML tags.&nbsp; In the second case, an application is vulnerable if it reads from an XML store and blindly constructs an HTML page to send back to the client.</p><p>During this subtask, you need to go through all web pages in the application under test and look for any XML interaction.&nbsp; Any page or method that uses XML to transmit data must be listed as a high risk component.&nbsp;&nbsp; Following are some common examples of what you need to look for when reviewing code for XML injection bugs.</p><h2><em>Identify the usage of XML parsers</em></h2><p>Server-side applications can choose from a wide variety of XML parsers depending on the language they are written (ASP, PHP, Java, etc.)&nbsp; It is important that you recognize if the application you’re testing uses any of these parsers.&nbsp; If so, it is a clear indication that the application manipulates XML.&nbsp; </p><ul><li>SAXParser (Java) </li><li>MSXML (including Microsoft XML DOM Parser) </li><li>Xerces (Java, C++, Perl) </li><li>Oracle XML Parser </li><li>XML Booster </li><li>XML::Parser (form Perl) </li><li>XParse</li></ul><p>This short list illustrates that the programmer has different choices when selecting an XML parser.&nbsp; Make sure to look for the presence of any of these.&nbsp; In addition, keep up with the latest XML parsing technology and research for additional parsers that your application might use.</p><h2><em>Look for code that writes XML from user-supplied input</em></h2><p>Any code that uses user-supplied input (from web forms, URLs, etc) must be marked as high risk.&nbsp; Below is an example that uses the input parameter from a URL to construct XML:</p><pre>set xmlDoc=CreateObject("Microsoft.XMLDOM")</pre><pre>xmlDoc.async="false"</pre><pre>xmlDoc.load("accounts.xml")&nbsp;</pre><pre>for each x in xmlDoc.documentElement.childNodes</pre><pre>&nbsp; document.write(x.nodename)</pre><pre>&nbsp; document.write(": ")</pre><pre>&nbsp; document.write(x.text)</pre><pre>&nbsp; document.write(Request.QueryString("input"))</pre><pre>next</pre><p><strong><em>&nbsp;</em></strong></p><h2><em>Detect applications that use the CDATA tag</em></h2><p>Look at both the application code and storage XML files to identify the usage of the CDATA tag.&nbsp; Identifying CDATA tags inside XML documents is easy.&nbsp; Just search the contents of all XML documents in your application looking for the string “CDATA”.&nbsp; Then track down the code that uses the data read from this kind of tag.&nbsp; Any component that directly writes the contents of CDATA tags to an HTML response is vulnerable to cross-site scripting attacks through XML injection:</p><pre>Response.Write(contents from CDATA tag)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ASP)</pre><pre>echo contents from CDATA tag;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PHP)</pre><pre>print contents from CDATA tag;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PHP)</pre><p>&nbsp;</p><h2><em>Don’t rely on XML Document Type Definitions (DTDs)</em></h2><p>Programmers might assume that defining XML tags using DTD<a href="about:blank#_edn3" name="_ednref3">[iii]</a> protects them against XML injection attacks.&nbsp; As we will see later on, this is a misconception.&nbsp; Include any document that handles XML (using DTD or not) as a high risk component. </p><p>&nbsp;</p><h2><em>Match High Risk Components with Entry Points</em></h2><p>Non-validated XML data can come from any application entry point.&nbsp; Make sure to cover all the possible sources of malicious data which might get passed to a client.&nbsp; Common data sources include:</p><ul><li>Web forms </li><li>URL contents </li><li>Flash parameters </li><li>XML store contents </li><li>Web service data </li><li>Graphical User Interface</li></ul><p>&nbsp;</p><p>List the high risk application components (usually web pages such as the ones in the scenarios above) and their related entry points to systematically aid with your testing: </p><p><br><br></p><table><tbody><tr><td><p><strong>Component</strong></p></td><td><p><strong>Line</strong></p></td><td><p><strong>URL</strong></p></td><td><p><strong>Form</strong></p></td><td><p><strong>Flash</strong></p></td><td><p><strong>DB</strong></p></td><td><p><strong>Service</strong></p></td></tr><tr><td><p><strong>CreateChecking.php</strong></p></td><td><p>101</p></td><td><p>X</p></td><td><p>X</p></td><td><p><strong>&nbsp;</strong></p></td><td><p><strong>&nbsp;</strong></p></td><td><p><strong>&nbsp;</strong></p></td></tr><tr><td><p><strong>&nbsp;</strong></p></td><td><p>112</p></td><td><p>X</p></td><td><p>X</p></td><td><p><strong>&nbsp;</strong></p></td><td><p><strong>&nbsp;</strong></p></td><td><p><strong>&nbsp;</strong></p></td></tr><tr><td><p><strong>&nbsp;</strong></p></td><td><p>165</p></td><td><p>X</p></td><td><p>X</p></td><td><p><strong>&nbsp;</strong></p></td><td><p><strong>&nbsp;</strong></p></td><td><p><strong>&nbsp;</strong></p></td></tr><tr><td><p><strong>Response.php</strong></p></td><td><p>1001</p></td><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td><td><p>X</p></td><td><p><strong>&nbsp;</strong></p></td></tr><tr><td><p><strong>&nbsp;</strong></p></td><td><p>1116</p></td><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td><td><p>X</p></td><td><p><strong>&nbsp;</strong></p></td></tr><tr><td><p><strong>Present.php</strong></p></td><td><p>234</p></td><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td><td><p>X</p></td><td><p><strong>&nbsp;</strong></p></td><td><p><strong>&nbsp;</strong></p></td></tr><tr><td><p><strong>&nbsp;</strong></p></td><td><p>531</p></td><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td><td><p>X</p></td><td><p><strong>&nbsp;</strong></p></td><td><p><strong>&nbsp;</strong></p></td></tr><tr><td><p><strong>showAccount.php</strong></p></td><td><p>432</p></td><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td><td><p>X</p></td></tr></tbody></table><p>&nbsp;</p><p>&nbsp;</p><h1>Step 3:&nbsp; Start Testing and Exploring&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </h1><p>This step of testing is focused on submitting basic XML injection fuzz strings and observing how the application reacts.&nbsp; Then, we will try to execute two simple XML injection attacks as shown in the previous scenarios:&nbsp; tag injection and CDATA XSS.&nbsp; </p><p>Try all of the tests in this step through the easiest entry point for each high risk component.&nbsp; In step 4 you will tune your test case data to cover the different formats and encoding depending on the remaining entry points.</p><p><strong><em>&nbsp;</em></strong></p><h2><em>Start with simple fuzz strings</em></h2><p>Successful XML injection testing depends on whether the tester is able to send XML data that will end up being processed as expected XML. </p><p><strong><em>Closing quotes and tag characters</em></strong></p><p>It is recommend that you start testing with a simple XML string consisting of a single quote, a closing tag character, an opening tag character and a double quote.&nbsp; Try these four characters separately and combined:</p><p>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; &lt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (separately)</p><p>or&nbsp; </p><p>'"&gt;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;'"&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&gt;'"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (combined)</p><p>Then, observe how the XML-based server responds.&nbsp; The idea is to modify a valid XML tag such as the first string below, to the second one.&nbsp; Here, set the <strong>$input</strong> variable to a single quote ('):</p><pre><strong>&lt;node attrib='$input'/&gt;</strong></pre><pre><strong></strong></pre><pre><strong>&lt;node attrib='''/&gt;</strong></pre><pre><strong></strong></pre><p>Because the <em>node</em> element will now have the <em>attrib</em> attribute set to <strong>''' (</strong>note the extra single quote), it will result in invalid XML.&nbsp; An invalid XML message from the server is a good indication that there are potential XML injection bugs present in the server application.</p><pre></pre><p><strong><em>Comment strings</em></strong></p><p>Another way to generate invalid XML is to add the start of an XML comment:&nbsp;</p><p>xyz&lt;!--</p><p>Let’s say that you entered the string above as the <em>username</em>.&nbsp; The resulting XML will now look like this and will end up being invalid:</p><pre></pre><pre>&lt;user&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;username&gt;xyz&lt;!--&lt;/username&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password&gt;qwerty&lt;/password&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;userid&gt;111&lt;userid/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;mail&gt;JohnyC@examplesite.com&lt;/mail&gt;</pre><pre>&lt;/user&gt;</pre><p><strong><em>Ampersand (&amp;)</em></strong></p><p>XML uses the ampersand character to refer to another entity in its user-defined XML schema.&nbsp; For example, if the user passes the following string as the <em>username,</em> it will result in the corresponding XML:</p><pre>&amp;amp;xyz</pre><p>Results in:</p><pre>&lt;user&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;username&gt;&amp;xyz&lt;/username&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password&gt;qwerty&lt;/password&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;userid&gt;111&lt;userid/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;mail&gt;JohnyC@examplesite.com&lt;/mail&gt;</pre><pre>&lt;/user&gt;&nbsp;</pre><p>This will attempt to refer to the <strong>&amp;xyz</strong> entity of the XML document.&nbsp;&nbsp; If the document doesn’t contain this entity, then the newly built tag above will result in an invalid XML document.</p><p><strong><em>&nbsp;</em></strong></p><h2><em>Learn from error messages to conduct a real attack</em></h2><p>The purpose of creating invalid XML documents is so that you can start gaining information about the underlying XML format based on error messages they generate.&nbsp; Let’s say you inserted the following fuzz string (‘) in an input field and the server responded with the following error message:</p><pre>Invalid XML:&nbsp;</pre><pre>&lt;user name='''/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;id ='1232'/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;realname='tester'&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password='ind3$truct'/&gt;</pre><pre>&lt;user&gt;</pre><p>Now, consider how you can utilize this information to create an additional, valid user while conserving the structure and format of the original XML document:</p><pre><strong>$input = attacker'&gt;&lt;id ='1234'/&gt;&lt;realname='hacker'&gt;&lt;password='qwerty'/&gt;&lt;/user&gt;</strong></pre><pre><strong>&lt;user name ='real_user</strong></pre><p>&nbsp;</p><p>results in the server creating an extra element:</p><pre>&lt;user name='attacker'/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;id ='1234'/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;realname='hacker'&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password='ind3$truct'/&gt;</pre><pre>&lt;/user&gt;</pre><pre>&lt;user name='real_user'/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;id ='1232'/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;realname='tester'&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password='ind3$truct'/&gt;</pre><pre>&lt;/user&gt;</pre><p><strong><em></em></strong></p><h2><em>Try to exploit CDATA tags with Cross-Site Scripting (XSS) attacks</em></h2><p>To finish this step try to exploit the contents of CDATA tags to see if you can execute an XSS attack.&nbsp; This test is quite straight forward, simply remember that the XML parser extracts all data enclosed in between the tags <strong>"&lt;![CDATA[" </strong>and <strong>"]]&gt;" </strong>to form a new string.&nbsp; For example:</p><pre>&lt;![CDATA[xyz]]&gt;</pre><p>Becomes:</p><pre>xyz</pre><p>In the same manner:</p><pre>&lt;![CDATA[&lt;]]&gt;script&lt;![CDATA[&gt;]]&gt;</pre><p>Becomes:</p><pre>&lt;script&gt;</pre><p>Finally:</p><pre>&lt;![CDATA[&lt;script&gt;alert('XSS')&lt;/script&gt;]]&gt;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</pre><p>Becomes:</p><pre>&lt;script&gt;alert('XSS')&lt;/script&gt;</pre><pre>&nbsp;</pre><h1>Step 4:&nbsp; Tune Test Cases</h1><p>During this step you must focus in modifying your test case data to cover all entry points based on the format of each specific entry point.&nbsp; In addition, you must tune your test case data in order to execute additional XML Injection payloads. </p><h2><em>Consider string format and encoding according to entry point</em></h2><p><strong><em>Web Forms</em></strong></p><p><strong><em></em></strong>Web forms are the easiest to test since they commonly allow most ASCII strings.&nbsp; An attacker can try entering this string into an input field, for instance in the web form below:</p>
<p><img src="X:\Trash\GE\clip_image001.png"></p><p>An attacker might try to enter this string in the email text field to execute an XML injection attack:</p><pre>JohnyC@examplesite.com&lt;/mail&gt;&lt;account type="savings"&gt;&lt;created&gt;03-02-2008&lt;/created&gt;&lt;number&gt;12345678&lt;/number&gt;&lt;balance&gt;1000000&lt;/balance&gt;&lt;/account&gt;</pre><p>It’s possible that client side checks are in place to match the contents of this text field with a valid email format.&nbsp; However, client side checks are easily bypassed by removing them at the attacker’s end.</p><p>&nbsp;</p><p><strong><em>URL Contents</em></strong></p><p><strong><em></em></strong><br>The format of URLs tends to be more complex than that of other input fields.&nbsp; This is due to the need for URLs to contain special or reserved characters, such as spaces, questions marks, single quotes, less than/greater than (&lt;/&gt;) symbols, and ampersands as data, rather than URL directives.&nbsp; The client <em>encodes</em> the URL and then sends it to the server, which decodes it so that the special characters can be processed as data.</p><p>How the encoding and decoding is done depends on the programming language in use.&nbsp; For example, sometimes the encoding function replaces the blank spaces with a plus (+) sign, or the characters %20, so that:</p><pre>Joseph Cohen</pre><p>Becomes:</p><pre>Joseph+Cohen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><p>or<strong></strong></p><pre>Joseph%20Cohen</pre><p>The most common URL encoding scheme consists of replacing special and reserved characters with a percent sign and then their hexadecimal values (e.g. <strong>%HH</strong>.)&nbsp; Using this encoding scheme the URL seen below will be translated from:</p><pre><strong>http://www.examplesite.com/CreateChecking.php?username=JohnyC&amp;password=qwerty&amp;email=JohnyC@examplesite.com&lt;/mail&gt;&lt;account type="savings"&gt;&lt;created&gt;03-02-2008&lt;/created&gt;&lt;number&gt;12345678&lt;/number&gt;&lt;balance&gt;1000000&lt;/balance&gt;&lt;/account&gt;</strong></pre><pre><strong></strong></pre><pre>to: &nbsp;</pre><pre><strong>http://www.examplesite.com/CreateChecking.php?username=JohnyC&amp;password=qwerty&amp;email=JohnyC%40examplesite.com%3c%2fmail%3e%3caccount%20type%3d%22savings%22%3e%3ccreated%3e03-02-2008%3c%2fcreated%3e%3cnumber%3e12345678%3c %2fnumber%3e%3cbalance%3e1000000%3c%2fbalance%3e%3c%2faccount%3e</strong></pre><pre><strong></strong></pre><p>This is because the below characters translate to their hex encoding like this:</p><p>&nbsp;</p><div><table><tbody><tr><td><p><strong>space</strong></p></td><td><p>@</p></td><td><p><strong>&lt;&nbsp;</strong></p></td><td><p>/</p></td><td><p>&gt;&nbsp;</p></td><td><p>=</p></td><td><p><strong>"</strong></p></td></tr><tr><td><p><strong>%20</strong></p></td><td><p><strong>%40</strong></p></td><td><p><strong>%3c</strong></p></td><td><p><strong>%2f</strong></p></td><td><p><strong>%3e</strong></p></td><td><p><strong>%3d</strong></p></td><td><p><strong>%22</strong></p></td></tr></tbody></table></div><p>&nbsp;</p><p><strong><em>Flash Parameters</em></strong></p><p>Flash uses the <strong>FlashVars </strong>parameter tag from HTML embedded objects to collect user input:<strong></strong></p><pre>&lt;object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"</pre><pre> codebase=""http://macromedia.com/cabs/swflash.cab#version=6,0,0,0""</pre><pre> width="250" height="250" id="flaMovie1" align="center"&gt;</pre><pre> &lt;param name=movie value="flaMovie1.swf"&gt;</pre><pre> &lt;param name=FlashVars value="input=userInput"&gt; </pre><pre>&nbsp;&lt;param name=quality value=high&gt; </pre><pre>&lt;/object&gt;</pre><pre><strong>&nbsp;</strong></pre><p>When testing through <strong>FlashVars </strong>you need to replace the <strong>userInput </strong>value with the XML injection string.&nbsp; </p><p>Note: Make sure that you also try different encodings when you test through this entry point.</p><p><strong><em>&nbsp;</em></strong></p><p><strong><em>XML store contents</em></strong></p><p><strong><em></em></strong></p><p>You must also tune your test case data when modifying the CDATA tag within XML files to execute a successful XSS attack.&nbsp; For instance, some applications may blacklist any input that contains the following string, thus not allowing it to be placed in the XML data store:&nbsp;</p><pre>&lt;script&gt; </pre><br><p>Here you may need to tweak your attack data to hide the script tags by adding extra CDATA tags<strong><em>:&nbsp;</em></strong><strong><em>&nbsp;</em></strong></p><pre>&lt;data&gt;&lt;[CDATA[&lt;sc]]&gt;&lt;![CDATA[ript&gt;alert('XSS')&lt;/sc]]&gt;&lt;![CDATA[ript&gt;]]&gt;&lt;/data&gt;</pre><p><strong><em></em></strong></p><p>At the end the contents within the CDATA tags get concatenated to construct a valid &lt;script&gt; tag.&nbsp; This will bypass any checks done for <strong>&lt;script&gt;</strong> before the final concatenation.<strong><em></em></strong></p><p><strong><em></em></strong>&nbsp;</p><p><strong><em>Additional entry points</em></strong><strong><em>&nbsp;</em></strong></p><p>Each application will have different ways of processing input from users, files, services, and other software entities.&nbsp; Ensure that you understand the format of each entry point and cover the different formats on each entry point for each high risk component.<strong><em></em></strong></p><p><strong><em>&nbsp;</em></strong></p><h2><em>Try additional payloads</em></h2><p>So far you’ve learned how to execute two payloads:</p><ul><li>Tag injection. </li><li>Cross-site scripting through CDATA tags.</li></ul><p>There are other payloads that you can try such as:</p><ul><li>Denial of service by consuming extra memory with excessive tags. </li><li>Denial of service by resource exhaustion via recursive elements. </li><li>Information disclosure attacks using XML External Entities (XEE)<a href="about:blank#_edn4" name="_ednref4">[iv]</a></li></ul><p>Each payload will require special tweaking of the XML attack data and might add new entry points to the scenario.&nbsp; However, it is imperative that you keep up to date with the latest attack techniques related to XML injection and include them in your security test suite.</p><p>&nbsp;</p><h1>Conclusions</h1><p>Testing for XML injection requires that you understand how the application under test uses XML.&nbsp; There are different scenarios ranging from when systems take XML as input, to when systems respond with XML as HTML output.&nbsp; To successfully test for XML injection you need to understand these different scenarios.&nbsp; Then, familiarize yourself with any potentially dangerous code and characteristics of any high risk components that are present.&nbsp; Create a test plan that matches high risk components with their different entry points.&nbsp; Then, start testing with simple test strings and observe how the application responds.&nbsp; Finally, to achieve the most complete coverage, ensure that you tune your attack data to cover all formats in all entry points, and try different, up to date payloads.</p><p>&nbsp;</p><div><br></div><div><hr></div><p><a href="about:blank#_ednref1" name="_edn1">[i]</a>Programming Web Services with SOAP.&nbsp; James Snell, Doug Tidwell &amp; Pavel Kulchenko.&nbsp; <a href="http://www.topxml.com/soap/articles/webservices/default.asp">http://www.topxml.com/soap/articles/webservices/default.asp</a></p><p><a href="about:blank#_ednref2" name="_edn2">[ii]</a> XML Web Services Basics.&nbsp; Roger Wolter.&nbsp; Microsoft Corporation.&nbsp; <a href="http://msdn2.microsoft.com/en-us/library/ms996507.aspx">http://msdn2.microsoft.com/en-us/library/ms996507.aspx</a></p><p><a href="about:blank#_ednref3" name="_edn3">[iii]</a> Document Type Definition.&nbsp; Wikipedia.&nbsp; <a href="http://en.wikipedia.org/wiki/Document_Type_Definition">http://en.wikipedia.org/wiki/Document_Type_Definition</a></p><p><a href="about:blank#_ednref4" name="_edn4">[iv]</a> Testing for XML Injection. OWASP. <a href="http://www.owasp.org/index.php/Testing_for_XML_Injection">http://www.owasp.org/index.php/Testing_for_XML_Injection</a></p><p>&nbsp;</p>]]></Data>
  </Content>
</TeamMentor_Article>