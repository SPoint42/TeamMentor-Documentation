<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="1240767300" Content_Hash="1321903725">
  <Metadata>
    <Id>6f1b7e6d-ebea-4011-81d8-82cac1dadf69</Id>
    <Library_Id>00000000-0000-0000-0000-000000000000</Library_Id>
    <Title>How to Test for XPath Injection Bugs</Title>
    <Category>Input and Data Validation</Category>
    <Phase>Test</Phase>
    <Technology> Any</Technology>
    <Type>How To</Type>
    <DirectLink />
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>Andres De Vivanco</Priority>
    <Status />
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<p><strong>&nbsp;</strong></p><h1>Applies to:</h1><ul><li>Web applications that use XPath to query XML data. Usually these applications are developed using ASP .Net, Java, PHP, Python and Ruby.</li></ul><p>&nbsp;</p><h1>Summary</h1><p>XPath is a language to query over XML data.&nbsp; Even though XPath is only used for querying data, it suffers from an injection vulnerability similar to SQL Injection.&nbsp; An attacker that manipulates the parameters used in an XPath query can modify the logic of an original query to perform an authentication bypass or execute information disclosure attacks. </p><p>It is recommended that you follow these steps to test for XPath Injection vulnerabilities:</p><ul><li>Step 1:&nbsp; Understand Attack Scenarios </li><li>Step 2:&nbsp; Analyze Causes and Countermeasures </li><li>Step 3:&nbsp; Start Testing and Exploring </li><li>Step 4:&nbsp; Fine-tune Test Cases</li></ul><p>&nbsp;</p><h1>Step 1:&nbsp; Understand Attack Scenarios</h1><p>First, you must understand the details of XPath attack scenarios.&nbsp; Similar to SQL injection, there are two types of XPath attacks:</p><ul><li>Normal XPath Injection </li><li>Blind XPath Injection</li></ul><p>&nbsp;</p><h2><em>Scenario 1: Normal XPath Injection </em></h2><p>In order to follow this and the next scenario, you must understand the background for XPath queries.&nbsp;&nbsp; XPath is a language that queries on XML data such as the file below:</p><pre>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt; <br>&lt;users&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;user&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;username&gt;johns&lt;/username&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password&gt;abc123&lt;/password&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;fullname&gt;John Smith&lt;/fullname&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/user&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;user&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;username&gt;billg&lt;/username&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password&gt;qwerty&lt;/password&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;fullname&gt;Bill Graves&lt;/fullname&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/user&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;user&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;username&gt;mrt&lt;/username&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password&gt;pr1v@t3&lt;/password&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;account&gt;Mr. T&lt;/account&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/user&gt; <br>&lt;/users&gt;<br>&nbsp;&nbsp;</pre><p>An XPath query consists of expressions containing backslashes (/) and dots (.) that are used to select nodes from the root node down and predicates enclosed in squared brackets ([]) used to include <em>when</em> conditions:</p><pre>/users/user/username&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>/users/user[username/text() ='johns'] </pre><p>The first query returns all username nodes while the second uses a predicate to search all usernames that match the string <em>johns</em>.</p><p>A common scenario is to use XPath to perform authentication.&nbsp; For example, the next query grabs a username and password from a web form and check if they match the ones of a valid user [i]:</p><pre>//users/user[username/text()='" + Request.QueryString("username") + "' and password/text()='" + Request.QueryString("password") + "']";</pre><p>If a user enters safe values (username=test, password=123) the application builds a standard authentication query:</p><pre>//users/user[username/text()='test' and password/text()='123']</pre><p>However an attacker can use the web form to submit the following injection string as the username and 123 as the password:</p><pre><strong>user' or '1' = '1</strong></pre><p>The resulting XPath query looks like this:</p><pre>/users/user[username/text()='<strong>user' or '1' = '1'</strong> and password/text()='123']</pre><p>Unlike SQL, XPath disallows commenting the rest of the expression so the attacker needs to insert an <em>or</em> condition that makes the password check irrelevant.&nbsp; The modified query returns all the users and the result is an attack against the authentication scheme in use.</p><p>&nbsp;</p><h2><em>Scenario 2: Blind XPath Injection </em></h2><p>Similar to blind SQL Injection, blind XPath Injection uses true and false conditions to infer confidential information.&nbsp; For example, an attacker wants to retrieve another user’s password but has no way of forcing the web application to display it on screen.&nbsp; The attacker uses blind XPath injection to steal the victim passwords character by character.&nbsp; </p><p>In the example below, the attacker now logs in with a valid account (johns) and tries to steal the password of another user.&nbsp;&nbsp; The attacker passes this attack string to check if the password for the third user in the document tree ("mrt") starts with an "a" [ii]:</p><pre><strong>johns' and substring((//user[position()=3]/child::node()[position()=2]),1,1)="a" and '1' = '1</strong></pre><p>The resulting XPath query looks the one below (note that the attacker needs to pass his valid username and password). The statement only returns true if the substring() condition is true:&nbsp; </p><pre>/users/user[username/text()='<strong>johns' and substring((//user[position()=3]/child::node()[position()=2]),1,1)="a" and '1' = '1</strong>' and password/text()='abc123']</pre><p>The attacker can craft similar blind commands to check data lengths using string-length().&nbsp; For instance, the next query returns true if the length of the target password is 7:</p><pre>/users/user[username/text()='<strong>johns' and string-length(//user[position()=3]/child::node()[position()=2]) and '1' = '1</strong>' and password/text()='abc123']</pre><p>The attacker can use additional functions such as count(), contains() to reveal both the contents of an XML store as well as its structure.&nbsp; Exploring the logic and hierarchy of an XML document is known as <em>XML Crawling</em>.</p><p>&nbsp;</p><h1>Step 2:&nbsp; Analyze Causes and Countermeasures</h1><p>The following step in testing for XPath Injection bugs is to understand what causes them and how to defend against them.</p><h2><em>XPath Injection Cause</em></h2><p>XPath Injection bugs exist due to poor input validation on and failing to sanitize the parameters used in an XPath query.&nbsp; For example, consider the following PHP code:</p><pre>&lt;?php<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $xml = simplexml_load_file("users.xml");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $result = $xml-&gt;xpath("//users/user[username/text()='"<strong>. $_GET['name'] </strong>. "']");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print_r($result);<br>?&gt;&nbsp;</pre><p>The PHP application uses the value passed in the URL parameter name in the XPath query without checking for injected commands.</p>
<p>Make sure to look at the API functions that your application uses to execute XPath queries.&nbsp;&nbsp; This table shows some common XPath APIs:&nbsp;</p><table><tbody><tr><td><pre><strong>Class/API</strong></pre></td><td><p><strong>Language</strong></p></td></tr><tr><td><pre>XPath.compile() </pre><pre>XPathExpression.evaluate()</pre><pre>&nbsp;</pre><pre>&nbsp;</pre></td><td><p>Java</p></td></tr><tr><td><pre>XPathNavigator.Select()</pre><p>XPathNavigator.Evaluate()</p></td><td><p>ASP .NET</p></td></tr><tr><td><p>xpath()</p></td><td><p>PHP</p></td></tr><tr><td><p>findvalue()</p></td><td><p>Perl</p></td></tr></tbody></table><p>&nbsp;</p><p><strong><em></em></strong></p><h2><em>XPath Injection Countermeasures</em></h2><p>XPath Injection vulnerabilities can be prevented by sanitizing user input.&nbsp; Specifically, the application needs to disallow any single or double quotes inputted by a user from making it to an XPath query.&nbsp;&nbsp; Sometimes the input doesn’t come directly from the user but is read from a persistent data source such as a database or an environment variable.&nbsp;&nbsp; In these cases, the application must sanitize the data coming from the data source and into the XPath query.</p>
<p>A proposed method [iii] consists of escaping any single quotes (VB):</p>
<pre>Dim FindUserXPath as String<br>FindUserXPath = "//Employee[UserName/text()='" &amp;<br>Request("Username").Replace("'", "&amp;apos;") &amp; "' And<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Password/text()='" &amp; Request("Password").Replace("'", "&amp;apos;") &amp; "']"<br></pre><p>Other methods include using parameterized XPath queries to properly handle user input. </p><p><strong>&nbsp;</strong></p><h1>Step 3:&nbsp; Start Testing and Exploring</h1><p>Now that you are familiar with the inner workings of XPath injection attacks and able to recognize both its causes and countermeasures, &nbsp;you must continue by executing basic XPath Injection black box test cases and exploring the results.</p><h2><em>Start with a simple test string</em></h2><p>Almost all XPath Injection strings must contain either a single or a double quote.&nbsp; Your first test pass must consist of submitting a string containing quotes to see how the application reacts to it:</p><pre><strong>abc'xyz"</strong></pre><p>If the server doesn’t return an error message and uses this string for an XPath query, it is almost certain that you’ll find an XPath Injection bug.&nbsp;</p><h2><em>Testing for Normal XPath Injection Authentication Bypass </em></h2><p>Hardware Requirements:&nbsp; One client computer and one server computer running the web application.</p><p>Tools:&nbsp;&nbsp; Web browser.</p><p>Testing steps:</p><ol><li>In the client computer, open the web browser and navigate to an authentication page in the server that uses XPath. </li><li>Enter a string (first for the username and then for the password) containing and additional true command. </li><li>Submit the authentication form to the server.</li></ol><br><p>Expected results:&nbsp; The application should not authenticate the client.&nbsp; </p><p><strong></strong></p><h2><em>Testing for Normal XPath Injection Information Disclosure</em></h2><p>Hardware Requirements:&nbsp; One client computer and one server computer running the web application.</p><p>Tools:&nbsp;&nbsp; Web browser.</p><p>Testing steps:</p><ol><li>In the client computer, open the web browser and navigate to any web form or other entry point that the server uses to build an XPath query. </li><li>Enter a string containing an additional command that executes an XPath query on another user’s node. </li><li>Submit the form to the server.</li></ol><br><p>Expected results:&nbsp; The application should not send a response containing data from the other user’s XML node.</p><p><strong></strong></p><h2><em>Testing for Blind XPath Injection Information Disclosure</em></h2><p>Hardware Requirements:&nbsp; One client box computer one server computer running the web application.</p><p>Tools:&nbsp;&nbsp; Web browser.</p><p>Testing steps:</p><ol><li>In the client computer, open the web browser and navigate to any web form or other entry point that the server uses to build an XPath query. </li><li>Enter a string containing an additional command that gathers partial knowledge of confidential information in the XML store. </li><li>Submit the form to the server. </li><li>Repeat steps 2 and 3 until the desired information is fully disclosed.</li></ol><br><p>Expected results:&nbsp; The application should not disclose the desired information.</p><p><strong>&nbsp;</strong></p><h1>Step 4:&nbsp; Fine-tune Test Case Data</h1><p>Finally, to achieve proper test case coverage, you must submit tests cases through different application entry points and adapt the format of the test data depending on the data format required for each entry point and each type of attack that can be carried out.&nbsp;&nbsp; </p><p>&nbsp;</p><h2><em>Tune test case data format according to entry points</em></h2><p>Like when testing for any injection bug, it is important that you adapt the data used in test cases according to the entry point under test.&nbsp; For example, when testing through URL parameters, the first string might look like the second or the third depending on the URL-encoding schema:</p>
<pre>user' or '1' = '1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; original test string</pre><pre>user'+or+'1'+=+'1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string under URL encoding schema 1</pre><pre>user'%20or%20'1'%20=%20'1&nbsp;&nbsp;&nbsp; string under URL encoding schema 2</pre><p>You must consider tuning the test case format for different entry points below such as URL parameters, web form fields, web services methods, flash parameters, etc.</p><p><strong><em>&nbsp;</em></strong></p><h2><em>Fine-tune test case data according to different attack objectives</em></h2><p>Finally, you must consider the different variations and constructs depending on the attack objective that the test case executed.&nbsp;&nbsp; The table below shows test case constructs depending on the objective.</p><table><tbody><tr><td><p><strong>Construct</strong></p></td><td><p><strong>Attack Objective</strong></p></td></tr><tr><td><br><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a' or '1=1'</p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a" or "1"="1</p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a'] or '1'='1</p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a"] or "1"="1</p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' or 1=1 or ''='</p><p>&nbsp;</p></td><td><p>Authentication bypass</p></td></tr><tr><td><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (string-length(S))</p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (substring(S,N,1))</p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count(//user/child::node())</p><p>&nbsp;</p></td><td><p>Blind XPath injection</p></td></tr><tr><td><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; namespace-uri(path)<a href="about:blank#_edn4" name="_ednref4">[iv]</a>.</p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name(path)</p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count(path/child::node())</p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count(path/child::text())</p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count(path/child::comment()) </p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count(path/child::*) count(path/child::processing-instruction()) </p></td><td><p>XML Crawling</p></td></tr></tbody></table><p>&nbsp;</p><h1>Conclusions</h1><p>XPath Injection is a vulnerability that allows bypassing authentication and accessing an entire XML document.&nbsp; It is caused because the vulnerable application fails to properly validate and sanitize user input and uses the input as part of an XPath query.&nbsp;&nbsp; There are different test cases to execute depending on the type of XPath Injection under test: normal or simple XPath Injection, blind XPath Injection, and XML crawling.&nbsp; </p><p>&nbsp;</p><div><br><hr><div><p>[i] <strong>OWASP - XPath Injection Overview</strong>. Roberto Suggi Liverani. <a href="http://www.owasp.org/index.php/XPATH_Injection">http://www.owasp.org/index.php/XPATH_Injection</a></p><br></div><div><p>[ii] <strong>OWASP - Blind XPath Injection.</strong> <a href="http://www.owasp.org/index.php/Blind_XPath_Injection">http://www.owasp.org/index.php/Blind_XPath_Injection</a>&nbsp;</p></div><div><p>[iii]&nbsp; <strong>OWASP -XPath Injection.</strong> <a href="http://www.owasp.org/index.php/XPath_Injection">http://www.owasp.org/index.php/XPath_Injection</a></p><br></div><div><p>[iv]&nbsp; <strong>Blind</strong> <strong>XPath</strong> <strong>Injection</strong>. Amit Klein. <a href="http://www.modsecurity.org/archive/amit/blind-xpath-injection.pdf">http://www.modsecurity.org/archive/amit/blind-xpath-injection.pdf</a></p><p>&nbsp;</p></div></div>]]></Data>
  </Content>
</TeamMentor_Article>